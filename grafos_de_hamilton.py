# -*- coding: utf-8 -*-
"""Grafos de Hamilton.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1WlukuTY816HlZirXKtXtFAOakp7RvESj
"""

# Programa em Python para a solução do problema do ciclo de hamilton
class Graph(): 
	def __init__(self, vertices): 
		self.graph = [[0 for column in range(vertices)] 
							       for row    in range(vertices)] 
		self.V = vertices 

	''' Verifique se este vértice é um vértice adjacente
      do vértice adicionado anteriormente e se este não está
      incluído no caminho anterior '''
	def isSafe(self, v, pos, path): 
		# Verifique se o vértice atual e o último vértice no caminho são adjacentes
		if self.graph[ path[pos-1] ][v] == 0: 
			return False
		# Verifique se o vértice atual ainda não está no caminho
		for vertex in path: 
			if vertex == v: 
				return False
		return True 

	# Uma função de utilidade recursiva para resolver problema do ciclo hamiltoniano 
	def hamCycleUtil(self, path, pos): 
		# caso base: se todos os vértices estão incluídos no caminho
		if pos == self.V: 
			# O último vértice deve ser adjacente ao primeiro vértice no caminho para fazer um ciclo 
			if self.graph[ path[pos-1] ][ path[0] ] == 1: 
				return True
			else: 
				return False
		# Experimenta vértices diferentes como um próximo candidato no Ciclo Hamiltoniano.
		for v in range(1,self.V): 
			if self.isSafe(v, pos, path) == True: 
				path[pos] = v 
				if self.hamCycleUtil(path, pos+1) == True: 
					return True
				# Remova o vértice atual se não levar a uma solução
				path[pos] = -1
		return False

	def hamCycle(self): #recebo o grafo
		path = [-1] * self.V #coloco todo o vetor do caminho como -1
		''' Vamos colocar o vértice 0 como o primeiro vértice
        no caminho. Se houver um ciclo hamiltoniano,
        então o caminho pode ser iniciado de qualquer ponto
        do ciclo, pois o gráfico não é direcionado '''
		path[0] = 0 # recebe 0(vertice de inicio)
		if self.hamCycleUtil(path,1) == False: #chamo a função e passo pra ela o vetor do caminho e o valor 1
			print ("Não existe Solução\n") 
			return False
		self.printSolution(path) 
		return True

	def printSolution(self, path): 
		print ("A solução existe: a seguir está um ciclo hamiltoniano") 
		for vertex in path: 
			print (vertex, end = " ") 
		print (path[0], "\n")

# Construção dos grafos de exemplo
g1 = Graph(5) 
g1.graph = [ [0, 1, 0, 1, 0], [1, 0, 1, 1, 1], 
			       [0, 1, 0, 0, 1,],[1, 1, 0, 0, 1], 
			                        [0, 1, 1, 1, 0], ] 
g2 = Graph(5) 
g2.graph = [ [0, 1, 0, 1, 0], [1, 0, 1, 1, 1], 
		         [0, 1, 0, 0, 1,],[1, 1, 0, 0, 0], 
		                          [0, 1, 1, 0, 0], ] 
g1.hamCycle();
g2.hamCycle(); 

# This code is contributed by Divyanshu Mehta - Geeks for Geeks